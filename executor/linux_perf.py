"""
 Linux Tools' Perf wrapper for Execute

 Usage:
  app = LinuxPerf(['myapp', '-flag', 'etc'], outp=Plugin)
  out, err = app.stat()

 Plugin: parses the output of a specific benchmark, returns a dictionary
         stderr is parsed by Perf's own local parser. If benchmark also
         prints to stderr, make sure they get combined in stdout before
         calling this wrapper, or use Execute directly, passing two output
         parsers.
"""

import execute
from pathlib import Path
import os
import shutil

class LinuxPerfParser(OutputParser):
    """All data generated by perf as well as external dictionary"""
    def __init__(self):
        super().__init__()
        self.fields = {
            'instructions' : r'([\d,]+)\s+instructions',
            'cycles' : r'([\d,]+)\s+cycles',
            'cpu-migrations' : r'([\d,]+)\s+cpu-migrations',
            'context-switches' : r'([\d,]+)\s+context-switches',
            'page-faults' : r'([\d,]+)\s+page-faults',
            'branches' : r'([\d,]+)\s+branches',
            'branch-misses' : r'([\d,]+)\s+branch-misses',
            'elapsed' : r'(\d+\.\d+)\s+seconds time elapsed'
        }

class LinuxPerf:
    """Main class, calls perf stat with some options, saves output for plugins
       to analyse, parses and stores the perf data in the object for later
       enquiry.
    """
    def __init__(self, program=None, plugin=None, perf=None):
        if program and not isinstance(program, list):
            raise TypeError("Program needs to be a list of arguments")
        if not program:
            raise ValueError("Need program arguments to run perf")
        if plugin and not isinstance(plugin, OutputParser):
            raise TypeError("Output parser needs to derive from OutputParser")

        self.program = program
        # external plugin, benchmark specific
        self.plugin = plugin
        # list of events
        self.events = list()
        # Special perf
        self.perf = os.path.abspath(perf)
        # Validate perf and permissions
        _validate()

    def _validate(self):
        # Verify that perf is actually installed
        if not self.perf:
            self.perf = shutil.which('perf')
        if not Path(self.perf).exists():
            raise RuntimeError("Perf '" + self.perf + "' not available")

        # Check that you have permissions to do anything
        CAP_SYS_ADMIN = Path('/proc/sys/kernel/perf_event_paranoid').read_text()
        if int(CAP_SYS_ADMIN) >= 3:
            raise RuntimeError("Can't run perf with CAP_SYS_ADMIN higher than 2")

    def stat(self, repeat=1, events=None):
        """Runs perf stat on the process, saving the output"""
        if repeat and not isinstance(repeat, int):
            raise TypeError("Repeat number must be an integer")
        if events and not isinstance(events, list):
            raise TypeError("Events needs to be a list")

        call = [self.perf, 'stat']

        # Repeat the run N times, reports stdev
        if repeat > 1:
            call.extend(['-r', repeat])

        # Collects only a few events (empty = all)
        if events:
            call.append('-e')
            ev_str = ''
            for event in self.events:
                ev_str += event
                ev_str += ','
            ev_str.pop()
            print(ev_str)
            call.append(ev_str)

        # Adding program to perf
        call.extend(self.program)

        # Call and collect output
        return execute.run(call, outp=plugin, errp=LinuxPerfParser)
